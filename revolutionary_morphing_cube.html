<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revolutionary Morphing Reality Cube - Never Before Seen</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(45deg, #000428, #004e92, #009ffd, #00d2ff);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            overflow-x: hidden;
            font-family: 'Courier New', monospace;
            height: 500vh; /* Make it scrollable */
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }

        .scroll-indicator {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 1000;
            text-align: center;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            z-index: 1000;
            transition: width 0.1s ease;
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
        }

        /* Particle system overlay */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>
    
    <div class="scroll-indicator">
        <div>SCROLL TO WITNESS</div>
        <div>THE TRANSFORMATION</div>
        <div style="margin-top: 10px;">â†“</div>
    </div>

    <div class="info-panel" id="infoPanel">
        <div>Transformation Stage: <span id="stage">Initialization</span></div>
        <div>Morph Progress: <span id="progress">0%</span></div>
        <div>Reality Distortion: <span id="distortion">Stable</span></div>
    </div>

    <div id="container"></div>
    <canvas class="particles" id="particleCanvas"></canvas>

    <!-- Three.js and Anime.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, cube, originalGeometry;
        let currentMorphStage = 0;
        let morphProgress = 0;
        let particleSystem;
        let scrollProgress = 0;

        // Initialize the revolutionary cube
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000428, 10, 50);

            // Camera with dynamic positioning
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 8);

            // Renderer with advanced settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            // Create the revolutionary morphing cube
            createRevolutionaryCube();
            
            // Advanced lighting system
            setupAdvancedLighting();
            
            // Particle system
            createParticleSystem();
            
            // Start the animation loop
            animate();
            
            // Setup scroll listeners
            setupScrollMagic();
        }

        function createRevolutionaryCube() {
            // Start with a highly subdivided cube for maximum morphing potential
            originalGeometry = new THREE.BoxGeometry(2, 2, 2, 16, 16, 16);
            
            // Revolutionary shader material with visible transformations
            const vertexShader = `
                uniform float time;
                uniform float morphFactor;
                uniform float scrollProgress;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                // Simple noise function
                float noise(vec3 p) {
                    return sin(p.x) * sin(p.y) * sin(p.z);
                }
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    vNormal = normal;
                    
                    vec3 pos = position;
                    vec3 newPos = pos;
                    
                    // Stage 1: Gentle breathing and pulsing (0-20%)
                    if (scrollProgress <= 0.2) {
                        float breathe = sin(time * 1.5) * 0.15;
                        float pulse = sin(time * 3.0 + length(pos) * 2.0) * 0.1;
                        newPos = pos + normal * (breathe + pulse) * scrollProgress * 5.0;
                    }
                    
                    // Stage 2: Wave distortion (20-40%)
                    else if (scrollProgress <= 0.4) {
                        float progress = (scrollProgress - 0.2) * 5.0;
                        float wave1 = sin(pos.x * 3.0 + time * 2.0) * 0.3;
                        float wave2 = cos(pos.y * 3.0 + time * 1.5) * 0.3;
                        float wave3 = sin(pos.z * 3.0 + time * 2.5) * 0.3;
                        
                        newPos.x = pos.x + wave1 * progress;
                        newPos.y = pos.y + wave2 * progress;
                        newPos.z = pos.z + wave3 * progress;
                    }
                    
                    // Stage 3: Sphere transformation (40-60%)
                    else if (scrollProgress <= 0.6) {
                        float progress = (scrollProgress - 0.4) * 5.0;
                        float radius = length(pos);
                        vec3 spherePos = normalize(pos) * (1.5 + sin(time + radius * 2.0) * 0.3);
                        newPos = mix(pos, spherePos, progress);
                    }
                    
                    // Stage 4: Torus transformation (60-80%)
                    else if (scrollProgress <= 0.8) {
                        float progress = (scrollProgress - 0.6) * 5.0;
                        
                        // Convert to cylindrical coordinates
                        float angle = atan(pos.z, pos.x);
                        float radius = length(vec2(pos.x, pos.z));
                        
                        // Torus parameters
                        float majorRadius = 1.5;
                        float minorRadius = 0.5 + sin(time * 2.0) * 0.2;
                        
                        // Torus equations
                        vec3 torusPos;
                        torusPos.x = (majorRadius + minorRadius * cos(pos.y * 3.14159)) * cos(angle);
                        torusPos.z = (majorRadius + minorRadius * cos(pos.y * 3.14159)) * sin(angle);
                        torusPos.y = minorRadius * sin(pos.y * 3.14159);
                        
                        newPos = mix(pos, torusPos, progress);
                    }
                    
                    // Stage 5: Chaotic explosion (80-100%)
                    else {
                        float progress = (scrollProgress - 0.8) * 5.0;
                        
                        // Multiple frequency distortions
                        float chaos1 = sin(pos.x * 5.0 + time * 4.0) * sin(pos.y * 3.0 + time * 3.0);
                        float chaos2 = cos(pos.z * 7.0 + time * 2.0) * sin(pos.x * 4.0 + time * 5.0);
                        float chaos3 = sin(length(pos) * 10.0 + time * 6.0);
                        
                        vec3 chaosOffset = vec3(chaos1, chaos2, chaos3) * progress * 0.8;
                        
                        // Explosive scaling
                        float explosionScale = 1.0 + progress * 2.0;
                        
                        newPos = (pos + chaosOffset) * explosionScale;
                    }
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float time;
                uniform float scrollProgress;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                void main() {
                    vec3 color = color1;
                    
                    // Stage-based coloring
                    if (scrollProgress <= 0.2) {
                        // Breathing blue-cyan
                        color = mix(vec3(0.0, 0.5, 1.0), vec3(0.0, 1.0, 1.0), sin(time * 2.0) * 0.5 + 0.5);
                    } else if (scrollProgress <= 0.4) {
                        // Wave colors - purple to pink
                        color = mix(vec3(0.5, 0.0, 1.0), vec3(1.0, 0.0, 0.5), (scrollProgress - 0.2) * 5.0);
                    } else if (scrollProgress <= 0.6) {
                        // Sphere colors - orange to yellow
                        color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 0.0), (scrollProgress - 0.4) * 5.0);
                    } else if (scrollProgress <= 0.8) {
                        // Torus colors - green spectrum
                        float t = (scrollProgress - 0.6) * 5.0;
                        color = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.5), t);
                    } else {
                        // Chaos colors - rainbow
                        float hue = fract(time * 0.5 + vPosition.x * 0.1 + vPosition.y * 0.1 + vPosition.z * 0.1);
                        color = vec3(
                            sin(hue * 6.28318 + 0.0) * 0.5 + 0.5,
                            sin(hue * 6.28318 + 2.09439) * 0.5 + 0.5,
                            sin(hue * 6.28318 + 4.18879) * 0.5 + 0.5
                        );
                    }
                    
                    // Add fresnel glow
                    vec3 viewDirection = normalize(cameraPosition - vPosition);
                    float fresnel = 1.0 - dot(normalize(vNormal), viewDirection);
                    fresnel = pow(fresnel, 1.5);
                    
                    color += fresnel * 0.3;
                    
                    // Add brightness based on transformation
                    color *= 0.8 + scrollProgress * 0.4;
                    
                    gl_FragColor = vec4(color, 0.9);
                }
            `;

            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    morphFactor: { value: 0 },
                    scrollProgress: { value: 0 },
                    color1: { value: new THREE.Color(0xff006e) },
                    color2: { value: new THREE.Color(0x8338ec) },
                    color3: { value: new THREE.Color(0x06ffa5) }
                },
                side: THREE.DoubleSide,
                transparent: false,
                wireframe: false
            });

            cube = new THREE.Mesh(originalGeometry, material);
            scene.add(cube);
        }

        function setupAdvancedLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // Multiple colored point lights that move
            const lights = [
                { color: 0xff006e, position: [5, 5, 5] },
                { color: 0x8338ec, position: [-5, -5, 5] },
                { color: 0x06ffa5, position: [5, -5, -5] },
                { color: 0x3a86ff, position: [-5, 5, -5] }
            ];

            lights.forEach((lightData, index) => {
                const light = new THREE.PointLight(lightData.color, 1, 50);
                light.position.set(...lightData.position);
                scene.add(light);

                // Animate lights with anime.js
                anime({
                    targets: light.position,
                    x: lightData.position[0] * -1,
                    y: lightData.position[1] * -1,
                    z: lightData.position[2] * -1,
                    duration: 5000 + index * 1000,
                    direction: 'alternate',
                    loop: true,
                    easing: 'easeInOutSine'
                });
            });
        }

        function createParticleSystem() {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 3 + 1,
                    opacity: Math.random() * 0.5 + 0.2
                });
            }
            
            function animateParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
                    if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;
                    
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
                    ctx.fill();
                });
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }

        function setupScrollMagic() {
            let ticking = false;
            let lastScrollProgress = 0;
            
            function updateOnScroll() {
                const scrollTop = window.pageYOffset;
                const docHeight = document.body.scrollHeight - window.innerHeight;
                scrollProgress = Math.min(scrollTop / docHeight, 1);
                
                // Update progress bar with anime.js
                anime({
                    targets: '#progressBar',
                    width: (scrollProgress * 100) + '%',
                    duration: 50,
                    easing: 'easeOutQuart'
                });
                
                // Update info panel
                updateInfoPanel();
                
                // Update cube material uniforms
                if (cube && cube.material.uniforms) {
                    cube.material.uniforms.scrollProgress.value = scrollProgress;
                }
                
                // Revolutionary camera choreography with anime.js
                const cameraDistance = 8 - scrollProgress * 6;
                const spiralRadius = 2 + scrollProgress * 3;
                const spiralHeight = scrollProgress * 4;
                
                anime({
                    targets: camera.position,
                    x: Math.sin(scrollProgress * Math.PI * 8) * spiralRadius,
                    y: Math.cos(scrollProgress * Math.PI * 6) * spiralHeight,
                    z: cameraDistance + Math.sin(scrollProgress * Math.PI * 4) * 2,
                    duration: 150,
                    easing: 'easeOutExpo'
                });
                
                // Multi-axis cube rotation with complex easing
                anime({
                    targets: cube.rotation,
                    x: scrollProgress * Math.PI * 12 + Math.sin(scrollProgress * Math.PI * 3) * 2,
                    y: scrollProgress * Math.PI * 16 + Math.cos(scrollProgress * Math.PI * 5) * 1.5,
                    z: scrollProgress * Math.PI * 8 + Math.sin(scrollProgress * Math.PI * 7) * 1,
                    duration: 200,
                    easing: 'easeOutElastic(1, .8)'
                });
                
                // Scale transformation based on scroll stage
                let targetScale = 1;
                if (scrollProgress > 0.8) {
                    targetScale = 1 + (scrollProgress - 0.8) * 3; // Moderate explosive growth
                } else if (scrollProgress > 0.6) {
                    targetScale = 1 + Math.sin(scrollProgress * Math.PI * 10) * 0.2; // Torus breathing
                } else if (scrollProgress > 0.4) {
                    targetScale = 1 + Math.sin(scrollProgress * Math.PI * 8) * 0.15; // Sphere pulsing
                } else if (scrollProgress > 0.2) {
                    targetScale = 1 + Math.sin(scrollProgress * Math.PI * 12) * 0.1; // Wave scaling
                } else {
                    targetScale = 1 + Math.sin(scrollProgress * Math.PI * 20) * 0.05; // Gentle breathing
                }
                
                anime({
                    targets: cube.scale,
                    x: targetScale,
                    y: targetScale,
                    z: targetScale,
                    duration: 300,
                    easing: 'easeOutBounce'
                });
                
                // Trigger special effects at transition points
                const progressDiff = Math.abs(scrollProgress - lastScrollProgress);
                if (progressDiff > 0.01) {
                    triggerTransitionEffects(scrollProgress, lastScrollProgress);
                }
                
                lastScrollProgress = scrollProgress;
                ticking = false;
            }
            
            function requestTick() {
                if (!ticking) {
                    requestAnimationFrame(updateOnScroll);
                    ticking = true;
                }
            }
            
            window.addEventListener('scroll', requestTick);
        }

        function updateInfoPanel() {
            const stages = [
                'Initialization',
                'Breathing Cube',
                'Wave Distortion', 
                'Sphere Transformation',
                'Torus Morphing',
                'Chaotic Explosion'
            ];
            
            const distortions = [
                'Stable',
                'Pulsing',
                'Undulating',
                'Spherical',
                'Toroidal',
                'Explosive'
            ];
            
            const stageIndex = Math.floor(scrollProgress * 5);
            
            // Animate text changes with anime.js
            anime({
                targets: '#stage',
                scale: [0.8, 1],
                opacity: [0.5, 1],
                duration: 300,
                easing: 'easeOutBack'
            });
            
            document.getElementById('stage').textContent = stages[stageIndex] || stages[5];
            document.getElementById('progress').textContent = Math.round(scrollProgress * 100) + '%';
            document.getElementById('distortion').textContent = distortions[stageIndex] || distortions[5];
        }
        
        function triggerTransitionEffects(currentProgress, lastProgress) {
            const transitionPoints = [0.2, 0.4, 0.6, 0.8];
            
            for (let point of transitionPoints) {
                if (lastProgress < point && currentProgress >= point) {
                    // Trigger dramatic transition effect
                    createTransitionExplosion(point);
                    shakeScreen();
                    flashColors();
                }
            }
        }
        
        function createTransitionExplosion(stage) {
            // Create temporary explosion elements
            for (let i = 0; i < 20; i++) {
                const explosion = document.createElement('div');
                explosion.style.position = 'fixed';
                explosion.style.left = '50%';
                explosion.style.top = '50%';
                explosion.style.width = '4px';
                explosion.style.height = '4px';
                explosion.style.background = `hsl(${stage * 360}, 100%, 50%)`;
                explosion.style.borderRadius = '50%';
                explosion.style.pointerEvents = 'none';
                explosion.style.zIndex = '999';
                document.body.appendChild(explosion);
                
                // Animate explosion particles
                anime({
                    targets: explosion,
                    translateX: anime.random(-300, 300),
                    translateY: anime.random(-300, 300),
                    scale: [0, anime.random(2, 5)],
                    opacity: [1, 0],
                    duration: anime.random(800, 1500),
                    easing: 'easeOutExpo',
                    complete: () => explosion.remove()
                });
            }
        }
        
        function shakeScreen() {
            anime({
                targets: 'body',
                translateX: [
                    { value: anime.random(-10, 10), duration: 50 },
                    { value: anime.random(-8, 8), duration: 50 },
                    { value: anime.random(-6, 6), duration: 50 },
                    { value: 0, duration: 50 }
                ],
                translateY: [
                    { value: anime.random(-8, 8), duration: 50 },
                    { value: anime.random(-6, 6), duration: 50 },
                    { value: anime.random(-4, 4), duration: 50 },
                    { value: 0, duration: 50 }
                ],
                easing: 'easeOutQuart'
            });
        }
        
        function flashColors() {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.background = `radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%)`;
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '998';
            document.body.appendChild(flash);
            
            anime({
                targets: flash,
                opacity: [0, 1, 0],
                duration: 200,
                easing: 'easeInOutQuad',
                complete: () => flash.remove()
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Update shader uniforms
            if (cube && cube.material.uniforms) {
                cube.material.uniforms.time.value = time;
            }
            
            // Camera look at cube with slight offset
            camera.lookAt(
                cube.position.x + Math.sin(time * 0.5) * 0.1,
                cube.position.y + Math.cos(time * 0.3) * 0.1,
                cube.position.z
            );
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const canvas = document.getElementById('particleCanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', onWindowResize);

        // Initialize everything
        init();

        // Add some extra anime.js magic for UI elements
        anime({
            targets: '.scroll-indicator',
            translateY: [-20, 20],
            opacity: [0.7, 1],
            duration: 2000,
            direction: 'alternate',
            loop: true,
            easing: 'easeInOutSine'
        });

        anime({
            targets: '.info-panel',
            scale: [0.95, 1.05],
            duration: 3000,
            direction: 'alternate',
            loop: true,
            easing: 'easeInOutQuad'
        });
    </script>
</body>
</html>